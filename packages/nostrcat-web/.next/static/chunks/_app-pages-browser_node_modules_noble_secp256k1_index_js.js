"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_noble_secp256k1_index_js"],{

/***/ "(app-pages-browser)/../../node_modules/@noble/secp256k1/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/@noble/secp256k1/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: function() { return /* binding */ secp256k1_CURVE; },\n/* harmony export */   Point: function() { return /* binding */ Point; },\n/* harmony export */   ProjectivePoint: function() { return /* binding */ Point; },\n/* harmony export */   Signature: function() { return /* binding */ Signature; },\n/* harmony export */   etc: function() { return /* binding */ etc; },\n/* harmony export */   getPublicKey: function() { return /* binding */ getPublicKey; },\n/* harmony export */   getSharedSecret: function() { return /* binding */ getSharedSecret; },\n/* harmony export */   sign: function() { return /* binding */ sign; },\n/* harmony export */   signAsync: function() { return /* binding */ signAsync; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   verify: function() { return /* binding */ verify; }\n/* harmony export */ });\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of secp256k1 ECDSA / Schnorr signatures & ECDH.\n * Compliant with RFC6979 & BIP340.\n * @module\n */\n/**\n * Curve params. secp256k1 is short weierstrass / koblitz curve. Equation is y² == x³ + ax + b.\n * * P = `2n**256n-2n**32n-2n**977n` // field over which calculations are done\n * * N = `2n**256n - 0x14551231950b75fc4402da1732fc9bebfn` // group order, amount of curve points\n * * h = `1n` // cofactor\n * * a = `0n` // equation param\n * * b = `7n` // equation param\n * * Gx, Gy are coordinates of Generator / base point\n */\nconst secp256k1_CURVE = {\n    p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,\n    n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,\n    h: 1n,\n    a: 0n,\n    b: 7n,\n    Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,\n    Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,\n};\nconst { p: P, n: N, Gx, Gy, b: _b } = secp256k1_CURVE;\nconst L = 32; // field / group byte length\nconst L2 = 64;\n// Helpers and Precomputes sections are reused between libraries\n// ## Helpers\n// ----------\n// error helper, messes-up stack trace\nconst err = (m = '') => {\n    throw new Error(m);\n};\nconst isBig = (n) => typeof n === 'bigint'; // is big integer\nconst isStr = (s) => typeof s === 'string'; // is string\nconst isBytes = (a) => a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n/** assert is Uint8Array (of specific length) */\nconst abytes = (a, l) => !isBytes(a) || (typeof l === 'number' && l > 0 && a.length !== l)\n    ? err('Uint8Array expected')\n    : a;\n/** create Uint8Array */\nconst u8n = (len) => new Uint8Array(len);\nconst u8fr = (buf) => Uint8Array.from(buf);\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst bytesToHex = (b) => Array.from(abytes(b))\n    .map((e) => padh(e, 2))\n    .join('');\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst hexToBytes = (hex) => {\n    const e = 'hex invalid';\n    if (!isStr(hex))\n        return err(e);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\n/** normalize hex or ui8a to ui8a */\nconst toU8 = (a, len) => abytes(isStr(a) ? hexToBytes(a) : u8fr(abytes(a)), len);\nconst cr = () => globalThis?.crypto; // WebCrypto is available in all modern environments\nconst subtle = () => cr()?.subtle ?? err('crypto.subtle must be defined');\n// prettier-ignore\nconst concatBytes = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\n/** WebCrypto OS-level CSPRNG (random number generator). Will throw when not available. */\nconst randomBytes = (len = L) => {\n    const c = cr();\n    return c.getRandomValues(u8n(len));\n};\nconst big = BigInt;\nconst arange = (n, min, max, msg = 'bad number: out of range') => isBig(n) && min <= n && n < max ? n : err(msg);\n/** modular division */\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst modN = (a) => M(a, N);\n/** Modular inversion using eucledian GCD (non-CT). No negative exponent for now. */\n// prettier-ignore\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n        const q = b / a, r = b % a;\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst callHash = (name) => {\n    // @ts-ignore\n    const fn = etc[name];\n    if (typeof fn !== 'function')\n        err('hashes.' + name + ' not set');\n    return fn;\n};\nconst apoint = (p) => (p instanceof Point ? p : err('Point expected'));\n// ## End of Helpers\n// -----------------\n/** secp256k1 formula. Koblitz curves are subclass of weierstrass curves with a=0, making it x³+b */\nconst koblitz = (x) => M(M(x * x) * x + _b);\n/** assert is field element or 0 */\nconst afield0 = (n) => arange(n, 0n, P);\n/** assert is field element */\nconst afield = (n) => arange(n, 1n, P);\n/** assert is group elem */\nconst agroup = (n) => arange(n, 1n, N);\nconst isEven = (y) => (y & 1n) === 0n;\n/** create Uint8Array of byte n */\nconst u8of = (n) => Uint8Array.of(n);\nconst getPrefix = (y) => u8of(isEven(y) ? 0x02 : 0x03);\n/** lift_x from BIP340 calculates square root. Validates x, then validates root*root. */\nconst lift_x = (x) => {\n    // Let c = x³ + 7 mod p. Fail if x ≥ p. (also fail if x < 1)\n    const c = koblitz(afield(x));\n    // c = √y\n    // y = c^((p+1)/4) mod p\n    // This formula works for fields p = 3 mod 4 -- a special, fast case.\n    // Paper: \"Square Roots from 1;24,51,10 to Dan Shanks\".\n    let r = 1n;\n    for (let num = c, e = (P + 1n) / 4n; e > 0n; e >>= 1n) {\n        // powMod: modular exponentiation.\n        if (e & 1n)\n            r = (r * num) % P; // Uses exponentiation by squaring.\n        num = (num * num) % P; // Not constant-time.\n    }\n    return M(r * r) === c ? r : err('sqrt invalid'); // check if result is valid\n};\n/** Point in 3d xyz projective coordinates. 3d takes less inversions than 2d. */\nclass Point {\n    static BASE;\n    static ZERO;\n    px;\n    py;\n    pz;\n    constructor(px, py, pz) {\n        this.px = afield0(px);\n        this.py = afield(py); // y can't be 0 in Projective\n        this.pz = afield0(pz);\n        Object.freeze(this);\n    }\n    /** Convert Uint8Array or hex string to Point. */\n    static fromBytes(bytes) {\n        abytes(bytes);\n        let p = undefined;\n        // First byte is prefix, rest is data. There are 2 kinds: compressed & uncompressed:\n        // * [0x02 or 0x03][32-byte x coordinate]\n        // * [0x04]        [32-byte x coordinate][32-byte y coordinate]\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        const x = sliceBytesNumBE(tail, 0, L);\n        const len = bytes.length;\n        // Compressed 33-byte point, 0x02 or 0x03 prefix\n        if (len === L + 1 && [0x02, 0x03].includes(head)) {\n            // Equation is y² == x³ + ax + b. We calculate y from x.\n            // y = √y²; there are two solutions: y, -y. Determine proper solution based on prefix\n            let y = lift_x(x);\n            const evenY = isEven(y);\n            const evenH = isEven(big(head));\n            if (evenH !== evenY)\n                y = M(-y);\n            p = new Point(x, y, 1n);\n        }\n        // Uncompressed 65-byte point, 0x04 prefix\n        if (len === L2 + 1 && head === 0x04)\n            p = new Point(x, sliceBytesNumBE(tail, L, L2), 1n);\n        // Validate point\n        return p ? p.assertValidity() : err('bad point: not on curve');\n    }\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = apoint(other); // checks class equality\n        const X1Z2 = M(X1 * Z2);\n        const X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2);\n        const Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n        return new Point(this.px, M(-this.py), this.pz);\n    }\n    /** Point doubling: P+P, complete formula. */\n    double() {\n        return this.add(this);\n    }\n    /**\n     * Point addition: P+Q, complete, exception-free formula\n     * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).\n     * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.\n     */\n    // prettier-ignore\n    add(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = apoint(other);\n        const a = 0n;\n        const b = _b;\n        let X3 = 0n, Y3 = 0n, Z3 = 0n;\n        const b3 = M(b * 3n);\n        let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1); // step 1\n        let t4 = M(X2 + Y2); // step 5\n        t3 = M(t3 * t4);\n        t4 = M(t0 + t1);\n        t3 = M(t3 - t4);\n        t4 = M(X1 + Z1);\n        let t5 = M(X2 + Z2); // step 10\n        t4 = M(t4 * t5);\n        t5 = M(t0 + t2);\n        t4 = M(t4 - t5);\n        t5 = M(Y1 + Z1);\n        X3 = M(Y2 + Z2); // step 15\n        t5 = M(t5 * X3);\n        X3 = M(t1 + t2);\n        t5 = M(t5 - X3);\n        Z3 = M(a * t4);\n        X3 = M(b3 * t2); // step 20\n        Z3 = M(X3 + Z3);\n        X3 = M(t1 - Z3);\n        Z3 = M(t1 + Z3);\n        Y3 = M(X3 * Z3);\n        t1 = M(t0 + t0); // step 25\n        t1 = M(t1 + t0);\n        t2 = M(a * t2);\n        t4 = M(b3 * t4);\n        t1 = M(t1 + t2);\n        t2 = M(t0 - t2); // step 30\n        t2 = M(a * t2);\n        t4 = M(t4 + t2);\n        t0 = M(t1 * t4);\n        Y3 = M(Y3 + t0);\n        t0 = M(t5 * t4); // step 35\n        X3 = M(t3 * X3);\n        X3 = M(X3 - t0);\n        t0 = M(t3 * t1);\n        Z3 = M(t5 * Z3);\n        Z3 = M(Z3 + t0); // step 40\n        return new Point(X3, Y3, Z3);\n    }\n    /**\n     * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.\n     * Uses {@link wNAF} for base point.\n     * Uses fake point to mitigate side-channel leakage.\n     * @param n scalar by which point is multiplied\n     * @param safe safe mode guards against timing attacks; unsafe mode is faster\n     */\n    multiply(n, safe = true) {\n        if (!safe && n === 0n)\n            return I;\n        agroup(n);\n        if (n === 1n)\n            return this;\n        if (this.equals(G))\n            return wNAF(n).p;\n        // init result point & fake point\n        let p = I;\n        let f = G;\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n            // if bit is present, add to point\n            // if not present, add to fake, for timing safety\n            if (n & 1n)\n                p = p.add(d);\n            else if (safe)\n                f = f.add(d);\n        }\n        return p;\n    }\n    /** Convert point to 2d xy affine point. (X, Y, Z) ∋ (x=X/Z, y=Y/Z) */\n    toAffine() {\n        const { px: x, py: y, pz: z } = this;\n        // fast-paths for ZERO point OR Z=1\n        if (this.equals(I))\n            return { x: 0n, y: 0n };\n        if (z === 1n)\n            return { x, y };\n        const iz = invert(z, P);\n        // (Z * Z^-1) must be 1, otherwise bad math\n        if (M(z * iz) !== 1n)\n            err('inverse invalid');\n        // x = X*Z^-1; y = Y*Z^-1\n        return { x: M(x * iz), y: M(y * iz) };\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const { x, y } = this.toAffine(); // convert to 2d xy affine point.\n        afield(x); // must be in range 1 <= x,y < P\n        afield(y);\n        // y² == x³ + ax + b, equation sides must be equal\n        return M(y * y) === koblitz(x) ? this : err('bad point: not on curve');\n    }\n    /** Converts point to 33/65-byte Uint8Array. */\n    toBytes(isCompressed = true) {\n        const { x, y } = this.assertValidity().toAffine();\n        const x32b = numTo32b(x);\n        if (isCompressed)\n            return concatBytes(getPrefix(y), x32b);\n        return concatBytes(u8of(0x04), x32b, numTo32b(y));\n    }\n    /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */\n    static fromAffine(ap) {\n        const { x, y } = ap;\n        return x === 0n && y === 0n ? I : new Point(x, y, 1n);\n    }\n    toHex(isCompressed) {\n        return bytesToHex(this.toBytes(isCompressed));\n    }\n    static fromPrivateKey(k) {\n        return G.multiply(toPrivScalar(k));\n    }\n    static fromHex(hex) {\n        return Point.fromBytes(toU8(hex));\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    toRawBytes(isCompressed) {\n        return this.toBytes(isCompressed);\n    }\n}\n/** Generator / base point */\nconst G = new Point(Gx, Gy, 1n);\n/** Identity / zero point */\nconst I = new Point(0n, 1n, 0n);\n// Static aliases\nPoint.BASE = G;\nPoint.ZERO = I;\n/** `Q = u1⋅G + u2⋅R`. Verifies Q is not ZERO. Unsafe: non-CT. */\nconst doubleScalarMulUns = (R, u1, u2) => {\n    return G.multiply(u1, false).add(R.multiply(u2, false)).assertValidity();\n};\nconst bytesToNumBE = (b) => big('0x' + (bytesToHex(b) || '0'));\nconst sliceBytesNumBE = (b, from, to) => bytesToNumBE(b.subarray(from, to));\nconst B256 = 2n ** 256n; // secp256k1 is weierstrass curve. Equation is x³ + ax + b.\n/** Number to 32b. Must be 0 <= num < B256. validate, pad, to bytes. */\nconst numTo32b = (num) => hexToBytes(padh(arange(num, 0n, B256), L2));\n/** Normalize private key to scalar (bigint). Verifies scalar is in range 1<s<N */\nconst toPrivScalar = (pr) => {\n    const num = isBig(pr) ? pr : bytesToNumBE(toU8(pr, L));\n    return arange(num, 1n, N, 'private key invalid 3');\n};\n/** For Signature malleability, validates sig.s is bigger than N/2. */\nconst highS = (n) => n > N >> 1n;\n/** Creates 33/65-byte public key from 32-byte private key. */\nconst getPublicKey = (privKey, isCompressed = true) => {\n    return G.multiply(toPrivScalar(privKey)).toBytes(isCompressed);\n};\n/** ECDSA Signature class. Supports only compact 64-byte representation, not DER. */\nclass Signature {\n    r;\n    s;\n    recovery;\n    constructor(r, s, recovery) {\n        this.r = agroup(r); // 1 <= r < N\n        this.s = agroup(s); // 1 <= s < N\n        if (recovery != null)\n            this.recovery = recovery;\n        Object.freeze(this);\n    }\n    /** Create signature from 64b compact (r || s) representation. */\n    static fromBytes(b) {\n        abytes(b, L2);\n        const r = sliceBytesNumBE(b, 0, L);\n        const s = sliceBytesNumBE(b, L, L2);\n        return new Signature(r, s);\n    }\n    toBytes() {\n        const { r, s } = this;\n        return concatBytes(numTo32b(r), numTo32b(s));\n    }\n    /** Copy signature, with newly added recovery bit. */\n    addRecoveryBit(bit) {\n        return new Signature(this.r, this.s, bit);\n    }\n    hasHighS() {\n        return highS(this.s);\n    }\n    toCompactRawBytes() {\n        return this.toBytes();\n    }\n    toCompactHex() {\n        return bytesToHex(this.toBytes());\n    }\n    recoverPublicKey(msg) {\n        return recoverPublicKey(this, msg);\n    }\n    static fromCompact(hex) {\n        return Signature.fromBytes(toU8(hex, L2));\n    }\n    assertValidity() {\n        return this;\n    }\n    normalizeS() {\n        const { r, s, recovery } = this;\n        return highS(s) ? new Signature(r, modN(-s), recovery) : this;\n    }\n}\n/**\n * RFC6979: ensure ECDSA msg is X bytes, convert to BigInt.\n * RFC suggests optional truncating via bits2octets.\n * FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits,\n * which matches bits2int. bits2int can produce res>N.\n */\nconst bits2int = (bytes) => {\n    const delta = bytes.length * 8 - 256;\n    if (delta > 1024)\n        err('msg invalid'); // our CUSTOM check, \"just-in-case\": prohibit long inputs\n    const num = bytesToNumBE(bytes);\n    return delta > 0 ? num >> big(delta) : num;\n};\n/** int2octets can't be used; pads small msgs with 0: BAD for truncation as per RFC vectors */\nconst bits2int_modN = (bytes) => modN(bits2int(abytes(bytes)));\nconst signOpts = { lowS: true };\nconst veriOpts = { lowS: true };\n// RFC6979 signature generation, preparation step.\nconst prepSig = (msgh, priv, opts = signOpts) => {\n    if (['der', 'recovered', 'canonical'].some((k) => k in opts))\n        // legacy opts\n        err('option not supported');\n    let { lowS, extraEntropy } = opts; // generates low-s sigs by default\n    if (lowS == null)\n        lowS = true; // RFC6979 3.2: we skip step A\n    const i2o = numTo32b; // int to octets\n    const h1i = bits2int_modN(toU8(msgh)); // msg bigint\n    const h1o = i2o(h1i); // msg octets\n    const d = toPrivScalar(priv); // validate private key, convert to bigint\n    const seed = [i2o(d), h1o]; // Step D of RFC6979 3.2\n    /** RFC6979 3.6: additional k' (optional). See {@link ExtraEntropy}. */\n    // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n    if (extraEntropy)\n        seed.push(extraEntropy === true ? randomBytes(L) : toU8(extraEntropy));\n    const m = h1i; // convert msg to bigint\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k⋅G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    const k2sig = (kBytes) => {\n        // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n        // Important: all mod() calls here must be done over N\n        const k = bits2int(kBytes);\n        if (!(1n <= k && k < N))\n            return; // Check 0 < k < CURVE.n\n        const q = G.multiply(k).toAffine(); // q = k⋅G\n        const r = modN(q.x); // r = q.x mod n\n        if (r === 0n)\n            return;\n        const ik = invert(k, N); // k^-1 mod n, NOT mod P\n        const s = modN(ik * modN(m + modN(d * r))); // s = k^-1(m + rd) mod n\n        if (s === 0n)\n            return;\n        let normS = s; // normalized S\n        let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n); // recovery bit (2 or 3, when q.x > n)\n        if (lowS && highS(s)) {\n            // if lowS was passed, ensure s is always\n            normS = modN(-s); // in the bottom half of CURVE.n\n            recovery ^= 1;\n        }\n        return new Signature(r, normS, recovery); // use normS, not s\n    };\n    return { seed: concatBytes(...seed), k2sig };\n};\n// HMAC-DRBG from NIST 800-90. Minimal, non-full-spec - used for RFC6979 signatures.\nconst hmacDrbg = (asynchronous) => {\n    let v = u8n(L); // Steps B, C of RFC6979 3.2: set hashLen\n    let k = u8n(L); // In our case, it's always equal to L\n    let i = 0; // Iterations counter, will throw when over max\n    const NULL = u8n(0);\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const max = 1000;\n    const _e = 'drbg: tried 1000 values';\n    if (asynchronous) {\n        // asynchronous=true\n        // h = hmac(K || V || ...)\n        const h = (...b) => etc.hmacSha256Async(k, v, ...b);\n        const reseed = async (seed = NULL) => {\n            // HMAC-DRBG reseed() function. Steps D-G\n            k = await h(u8of(0x00), seed); // k = hmac(K || V || 0x00 || seed)\n            v = await h(); // v = hmac(K || V)\n            if (seed.length === 0)\n                return;\n            k = await h(u8of(0x01), seed); // k = hmac(K || V || 0x01 || seed)\n            v = await h(); // v = hmac(K || V)\n        };\n        // HMAC-DRBG generate() function\n        const gen = async () => {\n            if (i++ >= max)\n                err(_e);\n            v = await h(); // v = hmac(K || V)\n            return v; // this diverges from noble-curves: we don't allow arbitrary output len!\n        };\n        // Do not reuse returned fn for more than 1 sig:\n        // 1) it's slower (JIT screws up). 2. unsafe (async race conditions)\n        return async (seed, pred) => {\n            reset();\n            await reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(await gen())))\n                await reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n    else {\n        // asynchronous=false; same as above, but synchronous\n        // h = hmac(K || V || ...)\n        const h = (...b) => callHash('hmacSha256Sync')(k, v, ...b);\n        const reseed = (seed = NULL) => {\n            // HMAC-DRBG reseed() function. Steps D-G\n            k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n            v = h(); // v = hmac(k || v)\n            if (seed.length === 0)\n                return;\n            k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n            v = h(); // v = hmac(k || v)\n        };\n        // HMAC-DRBG generate() function\n        const gen = () => {\n            if (i++ >= max)\n                err(_e);\n            v = h(); // v = hmac(k || v)\n            return v; // this diverges from noble-curves: we don't allow arbitrary output len!\n        };\n        // Do not reuse returned fn for more than 1 sig:\n        // 1) it's slower (JIT screws up). 2. unsafe (async race conditions)\n        return (seed, pred) => {\n            reset();\n            reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(gen())))\n                reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n};\n/**\n * Sign a msg hash using secp256k1. Async.\n * Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.2 & RFC6979.\n * It's suggested to enable hedging ({@link ExtraEntropy}) to prevent fault attacks.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` prevents malleability, `extraEntropy: true` enables hedging\n */\nconst signAsync = async (msgh, priv, opts = signOpts) => {\n    // Re-run drbg until k2sig returns ok\n    const { seed, k2sig } = prepSig(msgh, priv, opts);\n    const sig = await hmacDrbg(true)(seed, k2sig);\n    return sig;\n};\n/**\n * Sign a msg hash using secp256k1.\n * Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.2 & RFC6979.\n * It's suggested to enable hedging ({@link ExtraEntropy}) to prevent fault attacks.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` prevents malleability, `extraEntropy: true` enables hedging\n * @example\n * const sig = sign(sha256('hello'), privKey, { extraEntropy: true }).toBytes();\n */\nconst sign = (msgh, priv, opts = signOpts) => {\n    // Re-run drbg until k2sig returns ok\n    const { seed, k2sig } = prepSig(msgh, priv, opts);\n    const sig = hmacDrbg(false)(seed, k2sig);\n    return sig;\n};\n/**\n * Verify a signature using secp256k1.\n * Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.4.\n * Default lowS=true, prevents malleability.\n * @param sig - signature, 64-byte or Signature instance\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param pub - public key\n * @param opts - { lowS: true } is default, prohibits s >= CURVE.n/2 to prevent malleability\n */\nconst verify = (sig, msgh, pub, opts = veriOpts) => {\n    let { lowS } = opts;\n    if (lowS == null)\n        lowS = true;\n    if ('strict' in opts)\n        err('option not supported');\n    let sigg;\n    // Previous ver supported DER sigs.\n    // We throw error when DER is suspected now.\n    const rs = sig && typeof sig === 'object' && 'r' in sig;\n    if (!rs && toU8(sig).length !== L2)\n        err('signature must be 64 bytes');\n    try {\n        sigg = rs ? new Signature(sig.r, sig.s) : Signature.fromCompact(sig);\n        const h = bits2int_modN(toU8(msgh)); // Truncate hash\n        const P = Point.fromBytes(toU8(pub)); // Validate public key\n        const { r, s } = sigg;\n        if (lowS && highS(s))\n            return false; // lowS bans sig.s >= CURVE.n/2\n        const is = invert(s, N); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = doubleScalarMulUns(P, u1, u2).toAffine(); // R = u1⋅G + u2⋅P\n        // Stop if R is identity / zero point. Check is done inside `doubleScalarMulUns`\n        const v = modN(R.x); // R.x must be in N's field, not P's\n        return v === r; // mod(R.x, n) == r\n    }\n    catch (error) {\n        return false;\n    }\n};\n/**\n * ECDSA public key recovery. Requires msg hash and recovery id.\n * Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.6.\n */\nconst recoverPublicKey = (sig, msgh) => {\n    const { r, s, recovery } = sig;\n    // 0 or 1 recovery id determines sign of \"y\" coordinate.\n    // 2 or 3 means q.x was >N.\n    if (![0, 1, 2, 3].includes(recovery))\n        err('recovery id invalid');\n    const h = bits2int_modN(toU8(msgh, L)); // Truncate hash\n    const radj = recovery === 2 || recovery === 3 ? r + N : r;\n    afield(radj); // ensure q.x is still a field element\n    const head = getPrefix(big(recovery)); // head is 0x02 or 0x03\n    const Rb = concatBytes(head, numTo32b(radj)); // concat head + r\n    const R = Point.fromBytes(Rb);\n    const ir = invert(radj, N); // r^-1\n    const u1 = modN(-h * ir); // -hr^-1\n    const u2 = modN(s * ir); // sr^-1\n    return doubleScalarMulUns(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n};\n/**\n * Elliptic Curve Diffie-Hellman (ECDH) on secp256k1.\n * Result is **NOT hashed**. Use hash or KDF on it if you need.\n * @param privA private key A\n * @param pubB public key B\n * @param isCompressed 33-byte (true) or 65-byte (false) output\n * @returns public key C\n */\nconst getSharedSecret = (privA, pubB, isCompressed = true) => {\n    return Point.fromBytes(toU8(pubB)).multiply(toPrivScalar(privA)).toBytes(isCompressed);\n};\n// FIPS 186 B.4.1 compliant key generation produces private keys with modulo bias being neglible.\n// takes >N+8 bytes, returns (hash mod n-1)+1\nconst hashToPrivateKey = (hash) => {\n    hash = toU8(hash);\n    if (hash.length < L + 8 || hash.length > 1024)\n        err('expected 40-1024b');\n    const num = M(bytesToNumBE(hash), N - 1n);\n    return numTo32b(num + 1n);\n};\nconst randomPrivateKey = () => hashToPrivateKey(randomBytes(L + 16)); // FIPS 186 B.4.1.\nconst _sha = 'SHA-256';\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    concatBytes: concatBytes,\n    bytesToNumberBE: bytesToNumBE,\n    numberToBytesBE: numTo32b,\n    mod: M,\n    invert: invert, // math utilities\n    hmacSha256Async: async (key, ...msgs) => {\n        const s = subtle();\n        const name = 'HMAC';\n        const k = await s.importKey('raw', key, { name, hash: { name: _sha } }, false, ['sign']);\n        return u8n(await s.sign(name, k, concatBytes(...msgs)));\n    },\n    hmacSha256Sync: undefined, // For TypeScript. Actual logic is below\n    hashToPrivateKey: hashToPrivateKey,\n    randomBytes: randomBytes,\n};\n/** Curve-specific utilities for private keys. */\nconst utils = {\n    normPrivateKeyToScalar: toPrivScalar,\n    isValidPrivateKey: (key) => {\n        try {\n            return !!toPrivScalar(key);\n        }\n        catch (e) {\n            return false;\n        }\n    },\n    randomPrivateKey: randomPrivateKey,\n    precompute: (w = 8, p = G) => {\n        p.multiply(3n);\n        w;\n        return p;\n    },\n};\n// ## Precomputes\n// --------------\nconst W = 8; // W is window size\nconst scalarBits = 256;\nconst pwindows = Math.ceil(scalarBits / W) + 1; // 33 for W=8\nconst pwindowSize = 2 ** (W - 1); // 128 for W=8\nconst precompute = () => {\n    const points = [];\n    let p = G;\n    let b = p;\n    for (let w = 0; w < pwindows; w++) {\n        b = p;\n        points.push(b);\n        for (let i = 1; i < pwindowSize; i++) {\n            b = b.add(p);\n            points.push(b);\n        } // i=1, bc we skip 0\n        p = b.double();\n    }\n    return points;\n};\nlet Gpows = undefined; // precomputes for base point G\n// const-time negate\nconst ctneg = (cnd, p) => {\n    const n = p.negate();\n    return cnd ? n : p;\n};\n/**\n * Precomputes give 12x faster getPublicKey(), 10x sign(), 2x verify() by\n * caching multiples of G (base point). Cache is stored in 32MB of RAM.\n * Any time `G.multiply` is done, precomputes are used.\n * Not used for getSharedSecret, which instead multiplies random pubkey `P.multiply`.\n *\n * w-ary non-adjacent form (wNAF) precomputation method is 10% slower than windowed method,\n * but takes 2x less RAM. RAM reduction is possible by utilizing `.subtract`.\n *\n * !! Precomputes can be disabled by commenting-out call of the wNAF() inside Point#multiply().\n */\nconst wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    let p = I;\n    let f = G; // f must be G, or could become I in the end\n    const pow_2_w = 2 ** W; // 256 for W=8\n    const maxNum = pow_2_w; // 256 for W=8\n    const mask = big(pow_2_w - 1); // 255 for W=8 == mask 0b11111111\n    const shiftBy = big(W); // 8 for W=8\n    for (let w = 0; w < pwindows; w++) {\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > pwindowSize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off = w * pwindowSize;\n        const offF = off; // offsets, evaluate both\n        const offP = off + Math.abs(wbits) - 1;\n        const isEven = w % 2 !== 0; // conditions, evaluate both\n        const isNeg = wbits < 0;\n        if (wbits === 0) {\n            // off == I: can't add it. Adding random offF instead.\n            f = f.add(ctneg(isEven, comp[offF])); // bits are 0: add garbage to fake point\n        }\n        else {\n            p = p.add(ctneg(isNeg, comp[offP])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n};\n// !! Remove the export below to easily use in REPL / browser console\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEJBQTRCO0FBQ3BDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBLDRDQUE0QztBQUM1QyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxpQkFBaUI7QUFDakIsd0JBQXdCLGVBQWUsa0JBQWtCLEdBQUc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ3FKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9pbmRleC5qcz9kZmYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1zZWNwMjU2azEgLSBNSVQgTGljZW5zZSAoYykgMjAxOSBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8qKlxuICogNEtCIEpTIGltcGxlbWVudGF0aW9uIG9mIHNlY3AyNTZrMSBFQ0RTQSAvIFNjaG5vcnIgc2lnbmF0dXJlcyAmIEVDREguXG4gKiBDb21wbGlhbnQgd2l0aCBSRkM2OTc5ICYgQklQMzQwLlxuICogQG1vZHVsZVxuICovXG4vKipcbiAqIEN1cnZlIHBhcmFtcy4gc2VjcDI1NmsxIGlzIHNob3J0IHdlaWVyc3RyYXNzIC8ga29ibGl0eiBjdXJ2ZS4gRXF1YXRpb24gaXMgecKyID09IHjCsyArIGF4ICsgYi5cbiAqICogUCA9IGAybioqMjU2bi0ybioqMzJuLTJuKio5NzduYCAvLyBmaWVsZCBvdmVyIHdoaWNoIGNhbGN1bGF0aW9ucyBhcmUgZG9uZVxuICogKiBOID0gYDJuKioyNTZuIC0gMHgxNDU1MTIzMTk1MGI3NWZjNDQwMmRhMTczMmZjOWJlYmZuYCAvLyBncm91cCBvcmRlciwgYW1vdW50IG9mIGN1cnZlIHBvaW50c1xuICogKiBoID0gYDFuYCAvLyBjb2ZhY3RvclxuICogKiBhID0gYDBuYCAvLyBlcXVhdGlvbiBwYXJhbVxuICogKiBiID0gYDduYCAvLyBlcXVhdGlvbiBwYXJhbVxuICogKiBHeCwgR3kgYXJlIGNvb3JkaW5hdGVzIG9mIEdlbmVyYXRvciAvIGJhc2UgcG9pbnRcbiAqL1xuY29uc3Qgc2VjcDI1NmsxX0NVUlZFID0ge1xuICAgIHA6IDB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZm4sXG4gICAgbjogMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxbixcbiAgICBoOiAxbixcbiAgICBhOiAwbixcbiAgICBiOiA3bixcbiAgICBHeDogMHg3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4bixcbiAgICBHeTogMHg0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4bixcbn07XG5jb25zdCB7IHA6IFAsIG46IE4sIEd4LCBHeSwgYjogX2IgfSA9IHNlY3AyNTZrMV9DVVJWRTtcbmNvbnN0IEwgPSAzMjsgLy8gZmllbGQgLyBncm91cCBieXRlIGxlbmd0aFxuY29uc3QgTDIgPSA2NDtcbi8vIEhlbHBlcnMgYW5kIFByZWNvbXB1dGVzIHNlY3Rpb25zIGFyZSByZXVzZWQgYmV0d2VlbiBsaWJyYXJpZXNcbi8vICMjIEhlbHBlcnNcbi8vIC0tLS0tLS0tLS1cbi8vIGVycm9yIGhlbHBlciwgbWVzc2VzLXVwIHN0YWNrIHRyYWNlXG5jb25zdCBlcnIgPSAobSA9ICcnKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG0pO1xufTtcbmNvbnN0IGlzQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JzsgLy8gaXMgYmlnIGludGVnZXJcbmNvbnN0IGlzU3RyID0gKHMpID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJzsgLy8gaXMgc3RyaW5nXG5jb25zdCBpc0J5dGVzID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xuLyoqIGFzc2VydCBpcyBVaW50OEFycmF5IChvZiBzcGVjaWZpYyBsZW5ndGgpICovXG5jb25zdCBhYnl0ZXMgPSAoYSwgbCkgPT4gIWlzQnl0ZXMoYSkgfHwgKHR5cGVvZiBsID09PSAnbnVtYmVyJyAmJiBsID4gMCAmJiBhLmxlbmd0aCAhPT0gbClcbiAgICA/IGVycignVWludDhBcnJheSBleHBlY3RlZCcpXG4gICAgOiBhO1xuLyoqIGNyZWF0ZSBVaW50OEFycmF5ICovXG5jb25zdCB1OG4gPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pO1xuY29uc3QgdThmciA9IChidWYpID0+IFVpbnQ4QXJyYXkuZnJvbShidWYpO1xuY29uc3QgcGFkaCA9IChuLCBwYWQpID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KHBhZCwgJzAnKTtcbmNvbnN0IGJ5dGVzVG9IZXggPSAoYikgPT4gQXJyYXkuZnJvbShhYnl0ZXMoYikpXG4gICAgLm1hcCgoZSkgPT4gcGFkaChlLCAyKSlcbiAgICAuam9pbignJyk7XG5jb25zdCBDID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07IC8vIEFTQ0lJIGNoYXJhY3RlcnNcbmNvbnN0IF9jaCA9IChjaCkgPT4ge1xuICAgIGlmIChjaCA+PSBDLl8wICYmIGNoIDw9IEMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIEMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBDLkEgJiYgY2ggPD0gQy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoQy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBDLmEgJiYgY2ggPD0gQy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoQy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn07XG5jb25zdCBoZXhUb0J5dGVzID0gKGhleCkgPT4ge1xuICAgIGNvbnN0IGUgPSAnaGV4IGludmFsaWQnO1xuICAgIGlmICghaXNTdHIoaGV4KSlcbiAgICAgICAgcmV0dXJuIGVycihlKTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgcmV0dXJuIGVycihlKTtcbiAgICBjb25zdCBhcnJheSA9IHU4bihhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgLy8gdHJlYXQgZWFjaCBjaGFyIGFzIEFTQ0lJXG4gICAgICAgIGNvbnN0IG4xID0gX2NoKGhleC5jaGFyQ29kZUF0KGhpKSk7IC8vIHBhcnNlIGZpcnN0IGNoYXIsIG11bHRpcGx5IGl0IGJ5IDE2XG4gICAgICAgIGNvbnN0IG4yID0gX2NoKGhleC5jaGFyQ29kZUF0KGhpICsgMSkpOyAvLyBwYXJzZSBzZWNvbmQgY2hhclxuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGVycihlKTtcbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBleGFtcGxlOiAnQTknID0+IDEwKjE2ICsgOVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuLyoqIG5vcm1hbGl6ZSBoZXggb3IgdWk4YSB0byB1aThhICovXG5jb25zdCB0b1U4ID0gKGEsIGxlbikgPT4gYWJ5dGVzKGlzU3RyKGEpID8gaGV4VG9CeXRlcyhhKSA6IHU4ZnIoYWJ5dGVzKGEpKSwgbGVuKTtcbmNvbnN0IGNyID0gKCkgPT4gZ2xvYmFsVGhpcz8uY3J5cHRvOyAvLyBXZWJDcnlwdG8gaXMgYXZhaWxhYmxlIGluIGFsbCBtb2Rlcm4gZW52aXJvbm1lbnRzXG5jb25zdCBzdWJ0bGUgPSAoKSA9PiBjcigpPy5zdWJ0bGUgPz8gZXJyKCdjcnlwdG8uc3VidGxlIG11c3QgYmUgZGVmaW5lZCcpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBjb25jYXRCeXRlcyA9ICguLi5hcnJzKSA9PiB7XG4gICAgY29uc3QgciA9IHU4bihhcnJzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhYnl0ZXMoYSkubGVuZ3RoLCAwKSk7IC8vIGNyZWF0ZSB1OGEgb2Ygc3VtbWVkIGxlbmd0aFxuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBhcnJheSxcbiAgICBhcnJzLmZvckVhY2goYSA9PiB7IHIuc2V0KGEsIHBhZCk7IHBhZCArPSBhLmxlbmd0aDsgfSk7IC8vIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICByZXR1cm4gcjtcbn07XG4vKiogV2ViQ3J5cHRvIE9TLWxldmVsIENTUFJORyAocmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLiBXaWxsIHRocm93IHdoZW4gbm90IGF2YWlsYWJsZS4gKi9cbmNvbnN0IHJhbmRvbUJ5dGVzID0gKGxlbiA9IEwpID0+IHtcbiAgICBjb25zdCBjID0gY3IoKTtcbiAgICByZXR1cm4gYy5nZXRSYW5kb21WYWx1ZXModThuKGxlbikpO1xufTtcbmNvbnN0IGJpZyA9IEJpZ0ludDtcbmNvbnN0IGFyYW5nZSA9IChuLCBtaW4sIG1heCwgbXNnID0gJ2JhZCBudW1iZXI6IG91dCBvZiByYW5nZScpID0+IGlzQmlnKG4pICYmIG1pbiA8PSBuICYmIG4gPCBtYXggPyBuIDogZXJyKG1zZyk7XG4vKiogbW9kdWxhciBkaXZpc2lvbiAqL1xuY29uc3QgTSA9IChhLCBiID0gUCkgPT4ge1xuICAgIGNvbnN0IHIgPSBhICUgYjtcbiAgICByZXR1cm4gciA+PSAwbiA/IHIgOiBiICsgcjtcbn07XG5jb25zdCBtb2ROID0gKGEpID0+IE0oYSwgTik7XG4vKiogTW9kdWxhciBpbnZlcnNpb24gdXNpbmcgZXVjbGVkaWFuIEdDRCAobm9uLUNUKS4gTm8gbmVnYXRpdmUgZXhwb25lbnQgZm9yIG5vdy4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgaW52ZXJ0ID0gKG51bSwgbWQpID0+IHtcbiAgICBpZiAobnVtID09PSAwbiB8fCBtZCA8PSAwbilcbiAgICAgICAgZXJyKCdubyBpbnZlcnNlIG49JyArIG51bSArICcgbW9kPScgKyBtZCk7XG4gICAgbGV0IGEgPSBNKG51bSwgbWQpLCBiID0gbWQsIHggPSAwbiwgeSA9IDFuLCB1ID0gMW4sIHYgPSAwbjtcbiAgICB3aGlsZSAoYSAhPT0gMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhLCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHEsIG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIHJldHVybiBiID09PSAxbiA/IE0oeCwgbWQpIDogZXJyKCdubyBpbnZlcnNlJyk7IC8vIGIgaXMgZ2NkIGF0IHRoaXMgcG9pbnRcbn07XG5jb25zdCBjYWxsSGFzaCA9IChuYW1lKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGZuID0gZXRjW25hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIGVycignaGFzaGVzLicgKyBuYW1lICsgJyBub3Qgc2V0Jyk7XG4gICAgcmV0dXJuIGZuO1xufTtcbmNvbnN0IGFwb2ludCA9IChwKSA9PiAocCBpbnN0YW5jZW9mIFBvaW50ID8gcCA6IGVycignUG9pbnQgZXhwZWN0ZWQnKSk7XG4vLyAjIyBFbmQgb2YgSGVscGVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBzZWNwMjU2azEgZm9ybXVsYS4gS29ibGl0eiBjdXJ2ZXMgYXJlIHN1YmNsYXNzIG9mIHdlaWVyc3RyYXNzIGN1cnZlcyB3aXRoIGE9MCwgbWFraW5nIGl0IHjCsytiICovXG5jb25zdCBrb2JsaXR6ID0gKHgpID0+IE0oTSh4ICogeCkgKiB4ICsgX2IpO1xuLyoqIGFzc2VydCBpcyBmaWVsZCBlbGVtZW50IG9yIDAgKi9cbmNvbnN0IGFmaWVsZDAgPSAobikgPT4gYXJhbmdlKG4sIDBuLCBQKTtcbi8qKiBhc3NlcnQgaXMgZmllbGQgZWxlbWVudCAqL1xuY29uc3QgYWZpZWxkID0gKG4pID0+IGFyYW5nZShuLCAxbiwgUCk7XG4vKiogYXNzZXJ0IGlzIGdyb3VwIGVsZW0gKi9cbmNvbnN0IGFncm91cCA9IChuKSA9PiBhcmFuZ2UobiwgMW4sIE4pO1xuY29uc3QgaXNFdmVuID0gKHkpID0+ICh5ICYgMW4pID09PSAwbjtcbi8qKiBjcmVhdGUgVWludDhBcnJheSBvZiBieXRlIG4gKi9cbmNvbnN0IHU4b2YgPSAobikgPT4gVWludDhBcnJheS5vZihuKTtcbmNvbnN0IGdldFByZWZpeCA9ICh5KSA9PiB1OG9mKGlzRXZlbih5KSA/IDB4MDIgOiAweDAzKTtcbi8qKiBsaWZ0X3ggZnJvbSBCSVAzNDAgY2FsY3VsYXRlcyBzcXVhcmUgcm9vdC4gVmFsaWRhdGVzIHgsIHRoZW4gdmFsaWRhdGVzIHJvb3Qqcm9vdC4gKi9cbmNvbnN0IGxpZnRfeCA9ICh4KSA9PiB7XG4gICAgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLiBGYWlsIGlmIHgg4omlIHAuIChhbHNvIGZhaWwgaWYgeCA8IDEpXG4gICAgY29uc3QgYyA9IGtvYmxpdHooYWZpZWxkKHgpKTtcbiAgICAvLyBjID0g4oiaeVxuICAgIC8vIHkgPSBjXigocCsxKS80KSBtb2QgcFxuICAgIC8vIFRoaXMgZm9ybXVsYSB3b3JrcyBmb3IgZmllbGRzIHAgPSAzIG1vZCA0IC0tIGEgc3BlY2lhbCwgZmFzdCBjYXNlLlxuICAgIC8vIFBhcGVyOiBcIlNxdWFyZSBSb290cyBmcm9tIDE7MjQsNTEsMTAgdG8gRGFuIFNoYW5rc1wiLlxuICAgIGxldCByID0gMW47XG4gICAgZm9yIChsZXQgbnVtID0gYywgZSA9IChQICsgMW4pIC8gNG47IGUgPiAwbjsgZSA+Pj0gMW4pIHtcbiAgICAgICAgLy8gcG93TW9kOiBtb2R1bGFyIGV4cG9uZW50aWF0aW9uLlxuICAgICAgICBpZiAoZSAmIDFuKVxuICAgICAgICAgICAgciA9IChyICogbnVtKSAlIFA7IC8vIFVzZXMgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcuXG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgUDsgLy8gTm90IGNvbnN0YW50LXRpbWUuXG4gICAgfVxuICAgIHJldHVybiBNKHIgKiByKSA9PT0gYyA/IHIgOiBlcnIoJ3NxcnQgaW52YWxpZCcpOyAvLyBjaGVjayBpZiByZXN1bHQgaXMgdmFsaWRcbn07XG4vKiogUG9pbnQgaW4gM2QgeHl6IHByb2plY3RpdmUgY29vcmRpbmF0ZXMuIDNkIHRha2VzIGxlc3MgaW52ZXJzaW9ucyB0aGFuIDJkLiAqL1xuY2xhc3MgUG9pbnQge1xuICAgIHN0YXRpYyBCQVNFO1xuICAgIHN0YXRpYyBaRVJPO1xuICAgIHB4O1xuICAgIHB5O1xuICAgIHB6O1xuICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgdGhpcy5weCA9IGFmaWVsZDAocHgpO1xuICAgICAgICB0aGlzLnB5ID0gYWZpZWxkKHB5KTsgLy8geSBjYW4ndCBiZSAwIGluIFByb2plY3RpdmVcbiAgICAgICAgdGhpcy5weiA9IGFmaWVsZDAocHopO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmcgdG8gUG9pbnQuICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgICAgICBsZXQgcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRmlyc3QgYnl0ZSBpcyBwcmVmaXgsIHJlc3QgaXMgZGF0YS4gVGhlcmUgYXJlIDIga2luZHM6IGNvbXByZXNzZWQgJiB1bmNvbXByZXNzZWQ6XG4gICAgICAgIC8vICogWzB4MDIgb3IgMHgwM11bMzItYnl0ZSB4IGNvb3JkaW5hdGVdXG4gICAgICAgIC8vICogWzB4MDRdICAgICAgICBbMzItYnl0ZSB4IGNvb3JkaW5hdGVdWzMyLWJ5dGUgeSBjb29yZGluYXRlXVxuICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgY29uc3QgeCA9IHNsaWNlQnl0ZXNOdW1CRSh0YWlsLCAwLCBMKTtcbiAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAvLyBDb21wcmVzc2VkIDMzLWJ5dGUgcG9pbnQsIDB4MDIgb3IgMHgwMyBwcmVmaXhcbiAgICAgICAgaWYgKGxlbiA9PT0gTCArIDEgJiYgWzB4MDIsIDB4MDNdLmluY2x1ZGVzKGhlYWQpKSB7XG4gICAgICAgICAgICAvLyBFcXVhdGlvbiBpcyB5wrIgPT0geMKzICsgYXggKyBiLiBXZSBjYWxjdWxhdGUgeSBmcm9tIHguXG4gICAgICAgICAgICAvLyB5ID0g4oiaecKyOyB0aGVyZSBhcmUgdHdvIHNvbHV0aW9uczogeSwgLXkuIERldGVybWluZSBwcm9wZXIgc29sdXRpb24gYmFzZWQgb24gcHJlZml4XG4gICAgICAgICAgICBsZXQgeSA9IGxpZnRfeCh4KTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW5ZID0gaXNFdmVuKHkpO1xuICAgICAgICAgICAgY29uc3QgZXZlbkggPSBpc0V2ZW4oYmlnKGhlYWQpKTtcbiAgICAgICAgICAgIGlmIChldmVuSCAhPT0gZXZlblkpXG4gICAgICAgICAgICAgICAgeSA9IE0oLXkpO1xuICAgICAgICAgICAgcCA9IG5ldyBQb2ludCh4LCB5LCAxbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5jb21wcmVzc2VkIDY1LWJ5dGUgcG9pbnQsIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChsZW4gPT09IEwyICsgMSAmJiBoZWFkID09PSAweDA0KVxuICAgICAgICAgICAgcCA9IG5ldyBQb2ludCh4LCBzbGljZUJ5dGVzTnVtQkUodGFpbCwgTCwgTDIpLCAxbik7XG4gICAgICAgIC8vIFZhbGlkYXRlIHBvaW50XG4gICAgICAgIHJldHVybiBwID8gcC5hc3NlcnRWYWxpZGl0eSgpIDogZXJyKCdiYWQgcG9pbnQ6IG5vdCBvbiBjdXJ2ZScpO1xuICAgIH1cbiAgICAvKiogRXF1YWxpdHkgY2hlY2s6IGNvbXBhcmUgcG9pbnRzIFAmUS4gKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IGFwb2ludChvdGhlcik7IC8vIGNoZWNrcyBjbGFzcyBlcXVhbGl0eVxuICAgICAgICBjb25zdCBYMVoyID0gTShYMSAqIFoyKTtcbiAgICAgICAgY29uc3QgWDJaMSA9IE0oWDIgKiBaMSk7XG4gICAgICAgIGNvbnN0IFkxWjIgPSBNKFkxICogWjIpO1xuICAgICAgICBjb25zdCBZMloxID0gTShZMiAqIFoxKTtcbiAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICB9XG4gICAgaXMwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoSSk7XG4gICAgfVxuICAgIC8qKiBGbGlwIHBvaW50IG92ZXIgeSBjb29yZGluYXRlLiAqL1xuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBNKC10aGlzLnB5KSwgdGhpcy5weik7XG4gICAgfVxuICAgIC8qKiBQb2ludCBkb3VibGluZzogUCtQLCBjb21wbGV0ZSBmb3JtdWxhLiAqL1xuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2ludCBhZGRpdGlvbjogUCtRLCBjb21wbGV0ZSwgZXhjZXB0aW9uLWZyZWUgZm9ybXVsYVxuICAgICAqIChSZW5lcy1Db3N0ZWxsby1CYXRpbmEsIGFsZ28gMSBvZiBbMjAxNS8xMDYwXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjApKS5cbiAgICAgKiBDb3N0OiBgMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGRgLlxuICAgICAqL1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gYXBvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IDBuO1xuICAgICAgICBjb25zdCBiID0gX2I7XG4gICAgICAgIGxldCBYMyA9IDBuLCBZMyA9IDBuLCBaMyA9IDBuO1xuICAgICAgICBjb25zdCBiMyA9IE0oYiAqIDNuKTtcbiAgICAgICAgbGV0IHQwID0gTShYMSAqIFgyKSwgdDEgPSBNKFkxICogWTIpLCB0MiA9IE0oWjEgKiBaMiksIHQzID0gTShYMSArIFkxKTsgLy8gc3RlcCAxXG4gICAgICAgIGxldCB0NCA9IE0oWDIgKyBZMik7IC8vIHN0ZXAgNVxuICAgICAgICB0MyA9IE0odDMgKiB0NCk7XG4gICAgICAgIHQ0ID0gTSh0MCArIHQxKTtcbiAgICAgICAgdDMgPSBNKHQzIC0gdDQpO1xuICAgICAgICB0NCA9IE0oWDEgKyBaMSk7XG4gICAgICAgIGxldCB0NSA9IE0oWDIgKyBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgdDQgPSBNKHQ0ICogdDUpO1xuICAgICAgICB0NSA9IE0odDAgKyB0Mik7XG4gICAgICAgIHQ0ID0gTSh0NCAtIHQ1KTtcbiAgICAgICAgdDUgPSBNKFkxICsgWjEpO1xuICAgICAgICBYMyA9IE0oWTIgKyBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgdDUgPSBNKHQ1ICogWDMpO1xuICAgICAgICBYMyA9IE0odDEgKyB0Mik7XG4gICAgICAgIHQ1ID0gTSh0NSAtIFgzKTtcbiAgICAgICAgWjMgPSBNKGEgKiB0NCk7XG4gICAgICAgIFgzID0gTShiMyAqIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICBaMyA9IE0oWDMgKyBaMyk7XG4gICAgICAgIFgzID0gTSh0MSAtIFozKTtcbiAgICAgICAgWjMgPSBNKHQxICsgWjMpO1xuICAgICAgICBZMyA9IE0oWDMgKiBaMyk7XG4gICAgICAgIHQxID0gTSh0MCArIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICB0MSA9IE0odDEgKyB0MCk7XG4gICAgICAgIHQyID0gTShhICogdDIpO1xuICAgICAgICB0NCA9IE0oYjMgKiB0NCk7XG4gICAgICAgIHQxID0gTSh0MSArIHQyKTtcbiAgICAgICAgdDIgPSBNKHQwIC0gdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgIHQyID0gTShhICogdDIpO1xuICAgICAgICB0NCA9IE0odDQgKyB0Mik7XG4gICAgICAgIHQwID0gTSh0MSAqIHQ0KTtcbiAgICAgICAgWTMgPSBNKFkzICsgdDApO1xuICAgICAgICB0MCA9IE0odDUgKiB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgWDMgPSBNKHQzICogWDMpO1xuICAgICAgICBYMyA9IE0oWDMgLSB0MCk7XG4gICAgICAgIHQwID0gTSh0MyAqIHQxKTtcbiAgICAgICAgWjMgPSBNKHQ1ICogWjMpO1xuICAgICAgICBaMyA9IE0oWjMgKyB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9pbnQtYnktc2NhbGFyIG11bHRpcGxpY2F0aW9uLiBTY2FsYXIgbXVzdCBiZSBpbiByYW5nZSAxIDw9IG4gPCBDVVJWRS5uLlxuICAgICAqIFVzZXMge0BsaW5rIHdOQUZ9IGZvciBiYXNlIHBvaW50LlxuICAgICAqIFVzZXMgZmFrZSBwb2ludCB0byBtaXRpZ2F0ZSBzaWRlLWNoYW5uZWwgbGVha2FnZS5cbiAgICAgKiBAcGFyYW0gbiBzY2FsYXIgYnkgd2hpY2ggcG9pbnQgaXMgbXVsdGlwbGllZFxuICAgICAqIEBwYXJhbSBzYWZlIHNhZmUgbW9kZSBndWFyZHMgYWdhaW5zdCB0aW1pbmcgYXR0YWNrczsgdW5zYWZlIG1vZGUgaXMgZmFzdGVyXG4gICAgICovXG4gICAgbXVsdGlwbHkobiwgc2FmZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFzYWZlICYmIG4gPT09IDBuKVxuICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgIGFncm91cChuKTtcbiAgICAgICAgaWYgKG4gPT09IDFuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhHKSlcbiAgICAgICAgICAgIHJldHVybiB3TkFGKG4pLnA7XG4gICAgICAgIC8vIGluaXQgcmVzdWx0IHBvaW50ICYgZmFrZSBwb2ludFxuICAgICAgICBsZXQgcCA9IEk7XG4gICAgICAgIGxldCBmID0gRztcbiAgICAgICAgZm9yIChsZXQgZCA9IHRoaXM7IG4gPiAwbjsgZCA9IGQuZG91YmxlKCksIG4gPj49IDFuKSB7XG4gICAgICAgICAgICAvLyBpZiBiaXQgaXMgcHJlc2VudCwgYWRkIHRvIHBvaW50XG4gICAgICAgICAgICAvLyBpZiBub3QgcHJlc2VudCwgYWRkIHRvIGZha2UsIGZvciB0aW1pbmcgc2FmZXR5XG4gICAgICAgICAgICBpZiAobiAmIDFuKVxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNhZmUpXG4gICAgICAgICAgICAgICAgZiA9IGYuYWRkKGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKiogQ29udmVydCBwb2ludCB0byAyZCB4eSBhZmZpbmUgcG9pbnQuIChYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWikgKi9cbiAgICB0b0FmZmluZSgpIHtcbiAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAvLyBmYXN0LXBhdGhzIGZvciBaRVJPIHBvaW50IE9SIFo9MVxuICAgICAgICBpZiAodGhpcy5lcXVhbHMoSSkpXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwbiwgeTogMG4gfTtcbiAgICAgICAgaWYgKHogPT09IDFuKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpeiA9IGludmVydCh6LCBQKTtcbiAgICAgICAgLy8gKFogKiBaXi0xKSBtdXN0IGJlIDEsIG90aGVyd2lzZSBiYWQgbWF0aFxuICAgICAgICBpZiAoTSh6ICogaXopICE9PSAxbilcbiAgICAgICAgICAgIGVycignaW52ZXJzZSBpbnZhbGlkJyk7XG4gICAgICAgIC8vIHggPSBYKlpeLTE7IHkgPSBZKlpeLTFcbiAgICAgICAgcmV0dXJuIHsgeDogTSh4ICogaXopLCB5OiBNKHkgKiBpeikgfTtcbiAgICB9XG4gICAgLyoqIENoZWNrcyBpZiB0aGUgcG9pbnQgaXMgdmFsaWQgYW5kIG9uLWN1cnZlLiAqL1xuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTsgLy8gY29udmVydCB0byAyZCB4eSBhZmZpbmUgcG9pbnQuXG4gICAgICAgIGFmaWVsZCh4KTsgLy8gbXVzdCBiZSBpbiByYW5nZSAxIDw9IHgseSA8IFBcbiAgICAgICAgYWZpZWxkKHkpO1xuICAgICAgICAvLyB5wrIgPT0geMKzICsgYXggKyBiLCBlcXVhdGlvbiBzaWRlcyBtdXN0IGJlIGVxdWFsXG4gICAgICAgIHJldHVybiBNKHkgKiB5KSA9PT0ga29ibGl0eih4KSA/IHRoaXMgOiBlcnIoJ2JhZCBwb2ludDogbm90IG9uIGN1cnZlJyk7XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyBwb2ludCB0byAzMy82NS1ieXRlIFVpbnQ4QXJyYXkuICovXG4gICAgdG9CeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5hc3NlcnRWYWxpZGl0eSgpLnRvQWZmaW5lKCk7XG4gICAgICAgIGNvbnN0IHgzMmIgPSBudW1UbzMyYih4KTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZClcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhnZXRQcmVmaXgoeSksIHgzMmIpO1xuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXModThvZigweDA0KSwgeDMyYiwgbnVtVG8zMmIoeSkpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIDNkIHh5eiBwb2ludCBmcm9tIDJkIHh5LiAoMCwgMCkgPT4gKDAsIDEsIDApLCBub3QgKDAsIDAsIDEpICovXG4gICAgc3RhdGljIGZyb21BZmZpbmUoYXApIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBhcDtcbiAgICAgICAgcmV0dXJuIHggPT09IDBuICYmIHkgPT09IDBuID8gSSA6IG5ldyBQb2ludCh4LCB5LCAxbik7XG4gICAgfVxuICAgIHRvSGV4KGlzQ29tcHJlc3NlZCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShrKSB7XG4gICAgICAgIHJldHVybiBHLm11bHRpcGx5KHRvUHJpdlNjYWxhcihrKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKHRvVTgoaGV4KSk7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG59XG4vKiogR2VuZXJhdG9yIC8gYmFzZSBwb2ludCAqL1xuY29uc3QgRyA9IG5ldyBQb2ludChHeCwgR3ksIDFuKTtcbi8qKiBJZGVudGl0eSAvIHplcm8gcG9pbnQgKi9cbmNvbnN0IEkgPSBuZXcgUG9pbnQoMG4sIDFuLCAwbik7XG4vLyBTdGF0aWMgYWxpYXNlc1xuUG9pbnQuQkFTRSA9IEc7XG5Qb2ludC5aRVJPID0gSTtcbi8qKiBgUSA9IHUx4ouFRyArIHUy4ouFUmAuIFZlcmlmaWVzIFEgaXMgbm90IFpFUk8uIFVuc2FmZTogbm9uLUNULiAqL1xuY29uc3QgZG91YmxlU2NhbGFyTXVsVW5zID0gKFIsIHUxLCB1MikgPT4ge1xuICAgIHJldHVybiBHLm11bHRpcGx5KHUxLCBmYWxzZSkuYWRkKFIubXVsdGlwbHkodTIsIGZhbHNlKSkuYXNzZXJ0VmFsaWRpdHkoKTtcbn07XG5jb25zdCBieXRlc1RvTnVtQkUgPSAoYikgPT4gYmlnKCcweCcgKyAoYnl0ZXNUb0hleChiKSB8fCAnMCcpKTtcbmNvbnN0IHNsaWNlQnl0ZXNOdW1CRSA9IChiLCBmcm9tLCB0bykgPT4gYnl0ZXNUb051bUJFKGIuc3ViYXJyYXkoZnJvbSwgdG8pKTtcbmNvbnN0IEIyNTYgPSAybiAqKiAyNTZuOyAvLyBzZWNwMjU2azEgaXMgd2VpZXJzdHJhc3MgY3VydmUuIEVxdWF0aW9uIGlzIHjCsyArIGF4ICsgYi5cbi8qKiBOdW1iZXIgdG8gMzJiLiBNdXN0IGJlIDAgPD0gbnVtIDwgQjI1Ni4gdmFsaWRhdGUsIHBhZCwgdG8gYnl0ZXMuICovXG5jb25zdCBudW1UbzMyYiA9IChudW0pID0+IGhleFRvQnl0ZXMocGFkaChhcmFuZ2UobnVtLCAwbiwgQjI1NiksIEwyKSk7XG4vKiogTm9ybWFsaXplIHByaXZhdGUga2V5IHRvIHNjYWxhciAoYmlnaW50KS4gVmVyaWZpZXMgc2NhbGFyIGlzIGluIHJhbmdlIDE8czxOICovXG5jb25zdCB0b1ByaXZTY2FsYXIgPSAocHIpID0+IHtcbiAgICBjb25zdCBudW0gPSBpc0JpZyhwcikgPyBwciA6IGJ5dGVzVG9OdW1CRSh0b1U4KHByLCBMKSk7XG4gICAgcmV0dXJuIGFyYW5nZShudW0sIDFuLCBOLCAncHJpdmF0ZSBrZXkgaW52YWxpZCAzJyk7XG59O1xuLyoqIEZvciBTaWduYXR1cmUgbWFsbGVhYmlsaXR5LCB2YWxpZGF0ZXMgc2lnLnMgaXMgYmlnZ2VyIHRoYW4gTi8yLiAqL1xuY29uc3QgaGlnaFMgPSAobikgPT4gbiA+IE4gPj4gMW47XG4vKiogQ3JlYXRlcyAzMy82NS1ieXRlIHB1YmxpYyBrZXkgZnJvbSAzMi1ieXRlIHByaXZhdGUga2V5LiAqL1xuY29uc3QgZ2V0UHVibGljS2V5ID0gKHByaXZLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpID0+IHtcbiAgICByZXR1cm4gRy5tdWx0aXBseSh0b1ByaXZTY2FsYXIocHJpdktleSkpLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbn07XG4vKiogRUNEU0EgU2lnbmF0dXJlIGNsYXNzLiBTdXBwb3J0cyBvbmx5IGNvbXBhY3QgNjQtYnl0ZSByZXByZXNlbnRhdGlvbiwgbm90IERFUi4gKi9cbmNsYXNzIFNpZ25hdHVyZSB7XG4gICAgcjtcbiAgICBzO1xuICAgIHJlY292ZXJ5O1xuICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgIHRoaXMuciA9IGFncm91cChyKTsgLy8gMSA8PSByIDwgTlxuICAgICAgICB0aGlzLnMgPSBhZ3JvdXAocyk7IC8vIDEgPD0gcyA8IE5cbiAgICAgICAgaWYgKHJlY292ZXJ5ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgc2lnbmF0dXJlIGZyb20gNjRiIGNvbXBhY3QgKHIgfHwgcykgcmVwcmVzZW50YXRpb24uICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhiKSB7XG4gICAgICAgIGFieXRlcyhiLCBMMik7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZUJ5dGVzTnVtQkUoYiwgMCwgTCk7XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZUJ5dGVzTnVtQkUoYiwgTCwgTDIpO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMobnVtVG8zMmIociksIG51bVRvMzJiKHMpKTtcbiAgICB9XG4gICAgLyoqIENvcHkgc2lnbmF0dXJlLCB3aXRoIG5ld2x5IGFkZGVkIHJlY292ZXJ5IGJpdC4gKi9cbiAgICBhZGRSZWNvdmVyeUJpdChiaXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIGJpdCk7XG4gICAgfVxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICByZXR1cm4gaGlnaFModGhpcy5zKTtcbiAgICB9XG4gICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKTtcbiAgICB9XG4gICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoKSk7XG4gICAgfVxuICAgIHJlY292ZXJQdWJsaWNLZXkobXNnKSB7XG4gICAgICAgIHJldHVybiByZWNvdmVyUHVibGljS2V5KHRoaXMsIG1zZyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXModG9VOChoZXgsIEwyKSk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGhpZ2hTKHMpID8gbmV3IFNpZ25hdHVyZShyLCBtb2ROKC1zKSwgcmVjb3ZlcnkpIDogdGhpcztcbiAgICB9XG59XG4vKipcbiAqIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcywgY29udmVydCB0byBCaWdJbnQuXG4gKiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gKiBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cyxcbiAqIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLlxuICovXG5jb25zdCBiaXRzMmludCA9IChieXRlcykgPT4ge1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIDI1NjtcbiAgICBpZiAoZGVsdGEgPiAxMDI0KVxuICAgICAgICBlcnIoJ21zZyBpbnZhbGlkJyk7IC8vIG91ciBDVVNUT00gY2hlY2ssIFwianVzdC1pbi1jYXNlXCI6IHByb2hpYml0IGxvbmcgaW5wdXRzXG4gICAgY29uc3QgbnVtID0gYnl0ZXNUb051bUJFKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IGJpZyhkZWx0YSkgOiBudW07XG59O1xuLyoqIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogQkFEIGZvciB0cnVuY2F0aW9uIGFzIHBlciBSRkMgdmVjdG9ycyAqL1xuY29uc3QgYml0czJpbnRfbW9kTiA9IChieXRlcykgPT4gbW9kTihiaXRzMmludChhYnl0ZXMoYnl0ZXMpKSk7XG5jb25zdCBzaWduT3B0cyA9IHsgbG93UzogdHJ1ZSB9O1xuY29uc3QgdmVyaU9wdHMgPSB7IGxvd1M6IHRydWUgfTtcbi8vIFJGQzY5Nzkgc2lnbmF0dXJlIGdlbmVyYXRpb24sIHByZXBhcmF0aW9uIHN0ZXAuXG5jb25zdCBwcmVwU2lnID0gKG1zZ2gsIHByaXYsIG9wdHMgPSBzaWduT3B0cykgPT4ge1xuICAgIGlmIChbJ2RlcicsICdyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgLy8gbGVnYWN5IG9wdHNcbiAgICAgICAgZXJyKCdvcHRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIGxldCB7IGxvd1MsIGV4dHJhRW50cm9weSB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEFcbiAgICBjb25zdCBpMm8gPSBudW1UbzMyYjsgLy8gaW50IHRvIG9jdGV0c1xuICAgIGNvbnN0IGgxaSA9IGJpdHMyaW50X21vZE4odG9VOChtc2doKSk7IC8vIG1zZyBiaWdpbnRcbiAgICBjb25zdCBoMW8gPSBpMm8oaDFpKTsgLy8gbXNnIG9jdGV0c1xuICAgIGNvbnN0IGQgPSB0b1ByaXZTY2FsYXIocHJpdik7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgIGNvbnN0IHNlZWQgPSBbaTJvKGQpLCBoMW9dOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvKiogUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS4gU2VlIHtAbGluayBFeHRyYUVudHJvcHl9LiAqL1xuICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgIGlmIChleHRyYUVudHJvcHkpXG4gICAgICAgIHNlZWQucHVzaChleHRyYUVudHJvcHkgPT09IHRydWUgPyByYW5kb21CeXRlcyhMKSA6IHRvVTgoZXh0cmFFbnRyb3B5KSk7XG4gICAgY29uc3QgbSA9IGgxaTsgLy8gY29udmVydCBtc2cgdG8gYmlnaW50XG4gICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAvLyBUbyB0cmFuc2Zvcm0gayA9PiBTaWduYXR1cmU6XG4gICAgLy8gcSA9IGvii4VHXG4gICAgLy8gciA9IHEueCBtb2QgblxuICAgIC8vIHMgPSBrXi0xKG0gKyByZCkgbW9kIG5cbiAgICBjb25zdCBrMnNpZyA9IChrQnl0ZXMpID0+IHtcbiAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgIC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTtcbiAgICAgICAgaWYgKCEoMW4gPD0gayAmJiBrIDwgTikpXG4gICAgICAgICAgICByZXR1cm47IC8vIENoZWNrIDAgPCBrIDwgQ1VSVkUublxuICAgICAgICBjb25zdCBxID0gRy5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0ga+KLhUdcbiAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICBpZiAociA9PT0gMG4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlrID0gaW52ZXJ0KGssIE4pOyAvLyBrXi0xIG1vZCBuLCBOT1QgbW9kIFBcbiAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyBtb2ROKGQgKiByKSkpOyAvLyBzID0ga14tMShtICsgcmQpIG1vZCBuXG4gICAgICAgIGlmIChzID09PSAwbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5vcm1TID0gczsgLy8gbm9ybWFsaXplZCBTXG4gICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICBpZiAobG93UyAmJiBoaWdoUyhzKSkge1xuICAgICAgICAgICAgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgIG5vcm1TID0gbW9kTigtcyk7IC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBDVVJWRS5uXG4gICAgICAgICAgICByZWNvdmVyeSBePSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICB9O1xuICAgIHJldHVybiB7IHNlZWQ6IGNvbmNhdEJ5dGVzKC4uLnNlZWQpLCBrMnNpZyB9O1xufTtcbi8vIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwLiBNaW5pbWFsLCBub24tZnVsbC1zcGVjIC0gdXNlZCBmb3IgUkZDNjk3OSBzaWduYXR1cmVzLlxuY29uc3QgaG1hY0RyYmcgPSAoYXN5bmNocm9ub3VzKSA9PiB7XG4gICAgbGV0IHYgPSB1OG4oTCk7IC8vIFN0ZXBzIEIsIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuXG4gICAgbGV0IGsgPSB1OG4oTCk7IC8vIEluIG91ciBjYXNlLCBpdCdzIGFsd2F5cyBlcXVhbCB0byBMXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIG1heFxuICAgIGNvbnN0IE5VTEwgPSB1OG4oMCk7XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IG1heCA9IDEwMDA7XG4gICAgY29uc3QgX2UgPSAnZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnO1xuICAgIGlmIChhc3luY2hyb25vdXMpIHtcbiAgICAgICAgLy8gYXN5bmNocm9ub3VzPXRydWVcbiAgICAgICAgLy8gaCA9IGhtYWMoSyB8fCBWIHx8IC4uLilcbiAgICAgICAgY29uc3QgaCA9ICguLi5iKSA9PiBldGMuaG1hY1NoYTI1NkFzeW5jKGssIHYsIC4uLmIpO1xuICAgICAgICBjb25zdCByZXNlZWQgPSBhc3luYyAoc2VlZCA9IE5VTEwpID0+IHtcbiAgICAgICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgICAgICBrID0gYXdhaXQgaCh1OG9mKDB4MDApLCBzZWVkKTsgLy8gayA9IGhtYWMoSyB8fCBWIHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgICAgIHYgPSBhd2FpdCBoKCk7IC8vIHYgPSBobWFjKEsgfHwgVilcbiAgICAgICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBrID0gYXdhaXQgaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoSyB8fCBWIHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgICAgIHYgPSBhd2FpdCBoKCk7IC8vIHYgPSBobWFjKEsgfHwgVilcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgZ2VuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkrKyA+PSBtYXgpXG4gICAgICAgICAgICAgICAgZXJyKF9lKTtcbiAgICAgICAgICAgIHYgPSBhd2FpdCBoKCk7IC8vIHYgPSBobWFjKEsgfHwgVilcbiAgICAgICAgICAgIHJldHVybiB2OyAvLyB0aGlzIGRpdmVyZ2VzIGZyb20gbm9ibGUtY3VydmVzOiB3ZSBkb24ndCBhbGxvdyBhcmJpdHJhcnkgb3V0cHV0IGxlbiFcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRG8gbm90IHJldXNlIHJldHVybmVkIGZuIGZvciBtb3JlIHRoYW4gMSBzaWc6XG4gICAgICAgIC8vIDEpIGl0J3Mgc2xvd2VyIChKSVQgc2NyZXdzIHVwKS4gMi4gdW5zYWZlIChhc3luYyByYWNlIGNvbmRpdGlvbnMpXG4gICAgICAgIHJldHVybiBhc3luYyAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIGF3YWl0IHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoYXdhaXQgZ2VuKCkpKSlcbiAgICAgICAgICAgICAgICBhd2FpdCByZXNlZWQoKTsgLy8gdGVzdCBwcmVkaWNhdGUgdW50aWwgaXQgcmV0dXJucyBva1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhc3luY2hyb25vdXM9ZmFsc2U7IHNhbWUgYXMgYWJvdmUsIGJ1dCBzeW5jaHJvbm91c1xuICAgICAgICAvLyBoID0gaG1hYyhLIHx8IFYgfHwgLi4uKVxuICAgICAgICBjb25zdCBoID0gKC4uLmIpID0+IGNhbGxIYXNoKCdobWFjU2hhMjU2U3luYycpKGssIHYsIC4uLmIpO1xuICAgICAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IE5VTEwpID0+IHtcbiAgICAgICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgICAgICBrID0gaCh1OG9mKDB4MDApLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBrID0gaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkrKyA+PSBtYXgpXG4gICAgICAgICAgICAgICAgZXJyKF9lKTtcbiAgICAgICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgICAgIHJldHVybiB2OyAvLyB0aGlzIGRpdmVyZ2VzIGZyb20gbm9ibGUtY3VydmVzOiB3ZSBkb24ndCBhbGxvdyBhcmJpdHJhcnkgb3V0cHV0IGxlbiFcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRG8gbm90IHJldXNlIHJldHVybmVkIGZuIGZvciBtb3JlIHRoYW4gMSBzaWc6XG4gICAgICAgIC8vIDEpIGl0J3Mgc2xvd2VyIChKSVQgc2NyZXdzIHVwKS4gMi4gdW5zYWZlIChhc3luYyByYWNlIGNvbmRpdGlvbnMpXG4gICAgICAgIHJldHVybiAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgICAgICByZXNlZWQoKTsgLy8gdGVzdCBwcmVkaWNhdGUgdW50aWwgaXQgcmV0dXJucyBva1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogU2lnbiBhIG1zZyBoYXNoIHVzaW5nIHNlY3AyNTZrMS4gQXN5bmMuXG4gKiBGb2xsb3dzIFtTRUMxXShodHRwczovL3NlY2cub3JnL3NlYzEtdjIucGRmKSA0LjEuMiAmIFJGQzY5NzkuXG4gKiBJdCdzIHN1Z2dlc3RlZCB0byBlbmFibGUgaGVkZ2luZyAoe0BsaW5rIEV4dHJhRW50cm9weX0pIHRvIHByZXZlbnQgZmF1bHQgYXR0YWNrcy5cbiAqIEBwYXJhbSBtc2doIC0gbWVzc2FnZSBIQVNILCBub3QgbWVzc2FnZSBpdHNlbGYgZS5nLiBzaGEyNTYobWVzc2FnZSlcbiAqIEBwYXJhbSBwcml2IC0gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSBvcHRzIC0gYGxvd1M6IHRydWVgIHByZXZlbnRzIG1hbGxlYWJpbGl0eSwgYGV4dHJhRW50cm9weTogdHJ1ZWAgZW5hYmxlcyBoZWRnaW5nXG4gKi9cbmNvbnN0IHNpZ25Bc3luYyA9IGFzeW5jIChtc2doLCBwcml2LCBvcHRzID0gc2lnbk9wdHMpID0+IHtcbiAgICAvLyBSZS1ydW4gZHJiZyB1bnRpbCBrMnNpZyByZXR1cm5zIG9rXG4gICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2doLCBwcml2LCBvcHRzKTtcbiAgICBjb25zdCBzaWcgPSBhd2FpdCBobWFjRHJiZyh0cnVlKShzZWVkLCBrMnNpZyk7XG4gICAgcmV0dXJuIHNpZztcbn07XG4vKipcbiAqIFNpZ24gYSBtc2cgaGFzaCB1c2luZyBzZWNwMjU2azEuXG4gKiBGb2xsb3dzIFtTRUMxXShodHRwczovL3NlY2cub3JnL3NlYzEtdjIucGRmKSA0LjEuMiAmIFJGQzY5NzkuXG4gKiBJdCdzIHN1Z2dlc3RlZCB0byBlbmFibGUgaGVkZ2luZyAoe0BsaW5rIEV4dHJhRW50cm9weX0pIHRvIHByZXZlbnQgZmF1bHQgYXR0YWNrcy5cbiAqIEBwYXJhbSBtc2doIC0gbWVzc2FnZSBIQVNILCBub3QgbWVzc2FnZSBpdHNlbGYgZS5nLiBzaGEyNTYobWVzc2FnZSlcbiAqIEBwYXJhbSBwcml2IC0gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSBvcHRzIC0gYGxvd1M6IHRydWVgIHByZXZlbnRzIG1hbGxlYWJpbGl0eSwgYGV4dHJhRW50cm9weTogdHJ1ZWAgZW5hYmxlcyBoZWRnaW5nXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc2lnID0gc2lnbihzaGEyNTYoJ2hlbGxvJyksIHByaXZLZXksIHsgZXh0cmFFbnRyb3B5OiB0cnVlIH0pLnRvQnl0ZXMoKTtcbiAqL1xuY29uc3Qgc2lnbiA9IChtc2doLCBwcml2LCBvcHRzID0gc2lnbk9wdHMpID0+IHtcbiAgICAvLyBSZS1ydW4gZHJiZyB1bnRpbCBrMnNpZyByZXR1cm5zIG9rXG4gICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2doLCBwcml2LCBvcHRzKTtcbiAgICBjb25zdCBzaWcgPSBobWFjRHJiZyhmYWxzZSkoc2VlZCwgazJzaWcpO1xuICAgIHJldHVybiBzaWc7XG59O1xuLyoqXG4gKiBWZXJpZnkgYSBzaWduYXR1cmUgdXNpbmcgc2VjcDI1NmsxLlxuICogRm9sbG93cyBbU0VDMV0oaHR0cHM6Ly9zZWNnLm9yZy9zZWMxLXYyLnBkZikgNC4xLjQuXG4gKiBEZWZhdWx0IGxvd1M9dHJ1ZSwgcHJldmVudHMgbWFsbGVhYmlsaXR5LlxuICogQHBhcmFtIHNpZyAtIHNpZ25hdHVyZSwgNjQtYnl0ZSBvciBTaWduYXR1cmUgaW5zdGFuY2VcbiAqIEBwYXJhbSBtc2doIC0gbWVzc2FnZSBIQVNILCBub3QgbWVzc2FnZSBpdHNlbGYgZS5nLiBzaGEyNTYobWVzc2FnZSlcbiAqIEBwYXJhbSBwdWIgLSBwdWJsaWMga2V5XG4gKiBAcGFyYW0gb3B0cyAtIHsgbG93UzogdHJ1ZSB9IGlzIGRlZmF1bHQsIHByb2hpYml0cyBzID49IENVUlZFLm4vMiB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eVxuICovXG5jb25zdCB2ZXJpZnkgPSAoc2lnLCBtc2doLCBwdWIsIG9wdHMgPSB2ZXJpT3B0cykgPT4ge1xuICAgIGxldCB7IGxvd1MgfSA9IG9wdHM7XG4gICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgbG93UyA9IHRydWU7XG4gICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgIGVycignb3B0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBsZXQgc2lnZztcbiAgICAvLyBQcmV2aW91cyB2ZXIgc3VwcG9ydGVkIERFUiBzaWdzLlxuICAgIC8vIFdlIHRocm93IGVycm9yIHdoZW4gREVSIGlzIHN1c3BlY3RlZCBub3cuXG4gICAgY29uc3QgcnMgPSBzaWcgJiYgdHlwZW9mIHNpZyA9PT0gJ29iamVjdCcgJiYgJ3InIGluIHNpZztcbiAgICBpZiAoIXJzICYmIHRvVTgoc2lnKS5sZW5ndGggIT09IEwyKVxuICAgICAgICBlcnIoJ3NpZ25hdHVyZSBtdXN0IGJlIDY0IGJ5dGVzJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgc2lnZyA9IHJzID8gbmV3IFNpZ25hdHVyZShzaWcuciwgc2lnLnMpIDogU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZyk7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKHRvVTgobXNnaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQnl0ZXModG9VOChwdWIpKTsgLy8gVmFsaWRhdGUgcHVibGljIGtleVxuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNpZ2c7XG4gICAgICAgIGlmIChsb3dTICYmIGhpZ2hTKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBsb3dTIGJhbnMgc2lnLnMgPj0gQ1VSVkUubi8yXG4gICAgICAgIGNvbnN0IGlzID0gaW52ZXJ0KHMsIE4pOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBkb3VibGVTY2FsYXJNdWxVbnMoUCwgdTEsIHUyKS50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIC8vIFN0b3AgaWYgUiBpcyBpZGVudGl0eSAvIHplcm8gcG9pbnQuIENoZWNrIGlzIGRvbmUgaW5zaWRlIGBkb3VibGVTY2FsYXJNdWxVbnNgXG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7IC8vIFIueCBtdXN0IGJlIGluIE4ncyBmaWVsZCwgbm90IFAnc1xuICAgICAgICByZXR1cm4gdiA9PT0gcjsgLy8gbW9kKFIueCwgbikgPT0gclxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkuIFJlcXVpcmVzIG1zZyBoYXNoIGFuZCByZWNvdmVyeSBpZC5cbiAqIEZvbGxvd3MgW1NFQzFdKGh0dHBzOi8vc2VjZy5vcmcvc2VjMS12Mi5wZGYpIDQuMS42LlxuICovXG5jb25zdCByZWNvdmVyUHVibGljS2V5ID0gKHNpZywgbXNnaCkgPT4ge1xuICAgIGNvbnN0IHsgciwgcywgcmVjb3ZlcnkgfSA9IHNpZztcbiAgICAvLyAwIG9yIDEgcmVjb3ZlcnkgaWQgZGV0ZXJtaW5lcyBzaWduIG9mIFwieVwiIGNvb3JkaW5hdGUuXG4gICAgLy8gMiBvciAzIG1lYW5zIHEueCB3YXMgPk4uXG4gICAgaWYgKCFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjb3ZlcnkpKVxuICAgICAgICBlcnIoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTih0b1U4KG1zZ2gsIEwpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgIGNvbnN0IHJhZGogPSByZWNvdmVyeSA9PT0gMiB8fCByZWNvdmVyeSA9PT0gMyA/IHIgKyBOIDogcjtcbiAgICBhZmllbGQocmFkaik7IC8vIGVuc3VyZSBxLnggaXMgc3RpbGwgYSBmaWVsZCBlbGVtZW50XG4gICAgY29uc3QgaGVhZCA9IGdldFByZWZpeChiaWcocmVjb3ZlcnkpKTsgLy8gaGVhZCBpcyAweDAyIG9yIDB4MDNcbiAgICBjb25zdCBSYiA9IGNvbmNhdEJ5dGVzKGhlYWQsIG51bVRvMzJiKHJhZGopKTsgLy8gY29uY2F0IGhlYWQgKyByXG4gICAgY29uc3QgUiA9IFBvaW50LmZyb21CeXRlcyhSYik7XG4gICAgY29uc3QgaXIgPSBpbnZlcnQocmFkaiwgTik7IC8vIHJeLTFcbiAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgIHJldHVybiBkb3VibGVTY2FsYXJNdWxVbnMoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG59O1xuLyoqXG4gKiBFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUtSGVsbG1hbiAoRUNESCkgb24gc2VjcDI1NmsxLlxuICogUmVzdWx0IGlzICoqTk9UIGhhc2hlZCoqLiBVc2UgaGFzaCBvciBLREYgb24gaXQgaWYgeW91IG5lZWQuXG4gKiBAcGFyYW0gcHJpdkEgcHJpdmF0ZSBrZXkgQVxuICogQHBhcmFtIHB1YkIgcHVibGljIGtleSBCXG4gKiBAcGFyYW0gaXNDb21wcmVzc2VkIDMzLWJ5dGUgKHRydWUpIG9yIDY1LWJ5dGUgKGZhbHNlKSBvdXRwdXRcbiAqIEByZXR1cm5zIHB1YmxpYyBrZXkgQ1xuICovXG5jb25zdCBnZXRTaGFyZWRTZWNyZXQgPSAocHJpdkEsIHB1YkIsIGlzQ29tcHJlc3NlZCA9IHRydWUpID0+IHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKHRvVTgocHViQikpLm11bHRpcGx5KHRvUHJpdlNjYWxhcihwcml2QSkpLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbn07XG4vLyBGSVBTIDE4NiBCLjQuMSBjb21wbGlhbnQga2V5IGdlbmVyYXRpb24gcHJvZHVjZXMgcHJpdmF0ZSBrZXlzIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlibGUuXG4vLyB0YWtlcyA+Tis4IGJ5dGVzLCByZXR1cm5zIChoYXNoIG1vZCBuLTEpKzFcbmNvbnN0IGhhc2hUb1ByaXZhdGVLZXkgPSAoaGFzaCkgPT4ge1xuICAgIGhhc2ggPSB0b1U4KGhhc2gpO1xuICAgIGlmIChoYXNoLmxlbmd0aCA8IEwgKyA4IHx8IGhhc2gubGVuZ3RoID4gMTAyNClcbiAgICAgICAgZXJyKCdleHBlY3RlZCA0MC0xMDI0YicpO1xuICAgIGNvbnN0IG51bSA9IE0oYnl0ZXNUb051bUJFKGhhc2gpLCBOIC0gMW4pO1xuICAgIHJldHVybiBudW1UbzMyYihudW0gKyAxbik7XG59O1xuY29uc3QgcmFuZG9tUHJpdmF0ZUtleSA9ICgpID0+IGhhc2hUb1ByaXZhdGVLZXkocmFuZG9tQnl0ZXMoTCArIDE2KSk7IC8vIEZJUFMgMTg2IEIuNC4xLlxuY29uc3QgX3NoYSA9ICdTSEEtMjU2Jztcbi8qKiBNYXRoLCBoZXgsIGJ5dGUgaGVscGVycy4gTm90IGluIGB1dGlsc2AgYmVjYXVzZSB1dGlscyBzaGFyZSBBUEkgd2l0aCBub2JsZS1jdXJ2ZXMuICovXG5jb25zdCBldGMgPSB7XG4gICAgaGV4VG9CeXRlczogaGV4VG9CeXRlcyxcbiAgICBieXRlc1RvSGV4OiBieXRlc1RvSGV4LFxuICAgIGNvbmNhdEJ5dGVzOiBjb25jYXRCeXRlcyxcbiAgICBieXRlc1RvTnVtYmVyQkU6IGJ5dGVzVG9OdW1CRSxcbiAgICBudW1iZXJUb0J5dGVzQkU6IG51bVRvMzJiLFxuICAgIG1vZDogTSxcbiAgICBpbnZlcnQ6IGludmVydCwgLy8gbWF0aCB1dGlsaXRpZXNcbiAgICBobWFjU2hhMjU2QXN5bmM6IGFzeW5jIChrZXksIC4uLm1zZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHN1YnRsZSgpO1xuICAgICAgICBjb25zdCBuYW1lID0gJ0hNQUMnO1xuICAgICAgICBjb25zdCBrID0gYXdhaXQgcy5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lLCBoYXNoOiB7IG5hbWU6IF9zaGEgfSB9LCBmYWxzZSwgWydzaWduJ10pO1xuICAgICAgICByZXR1cm4gdThuKGF3YWl0IHMuc2lnbihuYW1lLCBrLCBjb25jYXRCeXRlcyguLi5tc2dzKSkpO1xuICAgIH0sXG4gICAgaG1hY1NoYTI1NlN5bmM6IHVuZGVmaW5lZCwgLy8gRm9yIFR5cGVTY3JpcHQuIEFjdHVhbCBsb2dpYyBpcyBiZWxvd1xuICAgIGhhc2hUb1ByaXZhdGVLZXk6IGhhc2hUb1ByaXZhdGVLZXksXG4gICAgcmFuZG9tQnl0ZXM6IHJhbmRvbUJ5dGVzLFxufTtcbi8qKiBDdXJ2ZS1zcGVjaWZpYyB1dGlsaXRpZXMgZm9yIHByaXZhdGUga2V5cy4gKi9cbmNvbnN0IHV0aWxzID0ge1xuICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IHRvUHJpdlNjYWxhcixcbiAgICBpc1ZhbGlkUHJpdmF0ZUtleTogKGtleSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhdG9Qcml2U2NhbGFyKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogcmFuZG9tUHJpdmF0ZUtleSxcbiAgICBwcmVjb21wdXRlOiAodyA9IDgsIHAgPSBHKSA9PiB7XG4gICAgICAgIHAubXVsdGlwbHkoM24pO1xuICAgICAgICB3O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxufTtcbi8vICMjIFByZWNvbXB1dGVzXG4vLyAtLS0tLS0tLS0tLS0tLVxuY29uc3QgVyA9IDg7IC8vIFcgaXMgd2luZG93IHNpemVcbmNvbnN0IHNjYWxhckJpdHMgPSAyNTY7XG5jb25zdCBwd2luZG93cyA9IE1hdGguY2VpbChzY2FsYXJCaXRzIC8gVykgKyAxOyAvLyAzMyBmb3IgVz04XG5jb25zdCBwd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gMTI4IGZvciBXPThcbmNvbnN0IHByZWNvbXB1dGUgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgbGV0IHAgPSBHO1xuICAgIGxldCBiID0gcDtcbiAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHB3aW5kb3dzOyB3KyspIHtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIHBvaW50cy5wdXNoKGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGIgPSBiLmFkZChwKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGIpO1xuICAgICAgICB9IC8vIGk9MSwgYmMgd2Ugc2tpcCAwXG4gICAgICAgIHAgPSBiLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xufTtcbmxldCBHcG93cyA9IHVuZGVmaW5lZDsgLy8gcHJlY29tcHV0ZXMgZm9yIGJhc2UgcG9pbnQgR1xuLy8gY29uc3QtdGltZSBuZWdhdGVcbmNvbnN0IGN0bmVnID0gKGNuZCwgcCkgPT4ge1xuICAgIGNvbnN0IG4gPSBwLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbmQgPyBuIDogcDtcbn07XG4vKipcbiAqIFByZWNvbXB1dGVzIGdpdmUgMTJ4IGZhc3RlciBnZXRQdWJsaWNLZXkoKSwgMTB4IHNpZ24oKSwgMnggdmVyaWZ5KCkgYnlcbiAqIGNhY2hpbmcgbXVsdGlwbGVzIG9mIEcgKGJhc2UgcG9pbnQpLiBDYWNoZSBpcyBzdG9yZWQgaW4gMzJNQiBvZiBSQU0uXG4gKiBBbnkgdGltZSBgRy5tdWx0aXBseWAgaXMgZG9uZSwgcHJlY29tcHV0ZXMgYXJlIHVzZWQuXG4gKiBOb3QgdXNlZCBmb3IgZ2V0U2hhcmVkU2VjcmV0LCB3aGljaCBpbnN0ZWFkIG11bHRpcGxpZXMgcmFuZG9tIHB1YmtleSBgUC5tdWx0aXBseWAuXG4gKlxuICogdy1hcnkgbm9uLWFkamFjZW50IGZvcm0gKHdOQUYpIHByZWNvbXB1dGF0aW9uIG1ldGhvZCBpcyAxMCUgc2xvd2VyIHRoYW4gd2luZG93ZWQgbWV0aG9kLFxuICogYnV0IHRha2VzIDJ4IGxlc3MgUkFNLiBSQU0gcmVkdWN0aW9uIGlzIHBvc3NpYmxlIGJ5IHV0aWxpemluZyBgLnN1YnRyYWN0YC5cbiAqXG4gKiAhISBQcmVjb21wdXRlcyBjYW4gYmUgZGlzYWJsZWQgYnkgY29tbWVudGluZy1vdXQgY2FsbCBvZiB0aGUgd05BRigpIGluc2lkZSBQb2ludCNtdWx0aXBseSgpLlxuICovXG5jb25zdCB3TkFGID0gKG4pID0+IHtcbiAgICBjb25zdCBjb21wID0gR3Bvd3MgfHwgKEdwb3dzID0gcHJlY29tcHV0ZSgpKTtcbiAgICBsZXQgcCA9IEk7XG4gICAgbGV0IGYgPSBHOyAvLyBmIG11c3QgYmUgRywgb3IgY291bGQgYmVjb21lIEkgaW4gdGhlIGVuZFxuICAgIGNvbnN0IHBvd18yX3cgPSAyICoqIFc7IC8vIDI1NiBmb3IgVz04XG4gICAgY29uc3QgbWF4TnVtID0gcG93XzJfdzsgLy8gMjU2IGZvciBXPThcbiAgICBjb25zdCBtYXNrID0gYmlnKHBvd18yX3cgLSAxKTsgLy8gMjU1IGZvciBXPTggPT0gbWFzayAwYjExMTExMTExXG4gICAgY29uc3Qgc2hpZnRCeSA9IGJpZyhXKTsgLy8gOCBmb3IgVz04XG4gICAgZm9yIChsZXQgdyA9IDA7IHcgPCBwd2luZG93czsgdysrKSB7XG4gICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7IC8vIGV4dHJhY3QgVyBiaXRzLlxuICAgICAgICBuID4+PSBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICBpZiAod2JpdHMgPiBwd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtO1xuICAgICAgICAgICAgbiArPSAxbjtcbiAgICAgICAgfSAvLyBzcGxpdCBpZiBiaXRzID4gbWF4OiArMjI0ID0+IDI1Ni0zMlxuICAgICAgICBjb25zdCBvZmYgPSB3ICogcHdpbmRvd1NpemU7XG4gICAgICAgIGNvbnN0IG9mZkYgPSBvZmY7IC8vIG9mZnNldHMsIGV2YWx1YXRlIGJvdGhcbiAgICAgICAgY29uc3Qgb2ZmUCA9IG9mZiArIE1hdGguYWJzKHdiaXRzKSAtIDE7XG4gICAgICAgIGNvbnN0IGlzRXZlbiA9IHcgJSAyICE9PSAwOyAvLyBjb25kaXRpb25zLCBldmFsdWF0ZSBib3RoXG4gICAgICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwO1xuICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIG9mZiA9PSBJOiBjYW4ndCBhZGQgaXQuIEFkZGluZyByYW5kb20gb2ZmRiBpbnN0ZWFkLlxuICAgICAgICAgICAgZiA9IGYuYWRkKGN0bmVnKGlzRXZlbiwgY29tcFtvZmZGXSkpOyAvLyBiaXRzIGFyZSAwOiBhZGQgZ2FyYmFnZSB0byBmYWtlIHBvaW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5hZGQoY3RuZWcoaXNOZWcsIGNvbXBbb2ZmUF0pKTsgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHAsIGYgfTsgLy8gcmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHMgZm9yIEpJVFxufTtcbi8vICEhIFJlbW92ZSB0aGUgZXhwb3J0IGJlbG93IHRvIGVhc2lseSB1c2UgaW4gUkVQTCAvIGJyb3dzZXIgY29uc29sZVxuZXhwb3J0IHsgc2VjcDI1NmsxX0NVUlZFIGFzIENVUlZFLCBldGMsIGdldFB1YmxpY0tleSwgZ2V0U2hhcmVkU2VjcmV0LCBQb2ludCwgUG9pbnQgYXMgUHJvamVjdGl2ZVBvaW50LCBzaWduLCBzaWduQXN5bmMsIFNpZ25hdHVyZSwgdXRpbHMsIHZlcmlmeSwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/secp256k1/index.js\n"));

/***/ })

}]);